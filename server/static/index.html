<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ID Central</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgo=" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <main class="page">
      <header class="page-header">
        <div class="brand">
          <h1 id="brand">__RP_ID__</h1>
        </div>
      </header>

      <div id="toast" class="toast" role="status" aria-live="polite" hidden>
        準備が整いました。
      </div>

      <section id="guest-view" class="panel">
        <div class="card">
          <h2>パスキーでサインイン</h2>
          <p id="guest-hint" class="hint">
            パスキーが登録されていれば自動的にサインインします。
          </p>
          <div class="button-row align-start">
            <button type="button" id="retry-signin" class="primary" hidden>
              パスキーでサインイン
            </button>
            <button
              type="button"
              id="open-create-account"
              class="secondary"
              hidden
            >
              パスキーでサインアップ
            </button>
          </div>
          <p id="conditional-status" class="hint" data-state="pending">
            パスキーの自動入力に対応しているか確認しています…
          </p>
          <p id="remote-notice" class="hint" hidden></p>
        </div>
      </section>

      <section id="fallback-view" class="panel" hidden>
        <div class="card">
          <h2>別のデバイスでサインイン</h2>
          <p class="hint">
            このブラウザーはパスキーに対応していません。スマートフォンなどの対応デバイスでQRコードを読み取り、パスキーで認証してください。
          </p>
          <div
            id="remote-qr"
            class="qr-placeholder"
            role="img"
            aria-live="polite"
          >
          </div>
          <p id="remote-status" class="hint" data-state="pending">
            QRコードを生成しています…
          </p>
          <div class="button-row align-start">
            <button type="button" id="remote-refresh" class="secondary">
              QRコードを再生成
            </button>
          </div>
        </div>
      </section>

      <section id="account-view" class="panel" hidden>
        <div class="card">
          <header class="section-header">
            <div>
              <h2>プロフィール情報</h2>
              <p class="hint" id="account-summary">
                サインイン中のユーザー情報が表示されます。
              </p>
            </div>
            <div class="section-actions">
              <button type="button" id="logout" class="secondary">
                ログアウト
              </button>
              <button type="button" id="delete-account" class="danger">
                アカウントを削除
              </button>
            </div>
          </header>
          <form id="profile-form" class="stack">
            <label class="field" for="account-username">
              <span>ユーザー名</span>
              <input
                id="account-username"
                type="text"
                name="username"
                autocomplete="username"
                required
              />
            </label>
            <label class="field" for="account-display-name">
              <span>表示名</span>
              <input
                id="account-display-name"
                type="text"
                name="displayName"
                autocomplete="name"
              />
            </label>
            <div class="button-row align-start">
              <button type="submit" class="primary">変更を保存</button>
            </div>
          </form>
        </div>

        <div class="card">
          <header class="section-header">
            <div>
              <h2>パスキー</h2>
              <p class="hint">
                新しいデバイスを登録したり、不要な鍵を削除できます。
              </p>
            </div>
            <div class="section-actions">
              <button
                type="button"
                id="add-passkey"
                class="secondary accent"
              >
                別の鍵を追加
              </button>
            </div>
          </header>
          <ul id="credential-list" class="credentials">
            <li class="empty">サインインするとパスキーが表示されます。</li>
          </ul>
        </div>
      </section>

      <dialog id="passkey-dialog">
        <form id="passkey-form" class="dialog-form">
          <h2 id="passkey-dialog-title">パスキーを追加</h2>
          <p id="passkey-dialog-description" class="hint">
            後から分かるように鍵に名前を付けてください。
          </p>
          <label class="field" id="passkey-username-field" hidden>
            <span>ユーザー名</span>
            <input
              id="passkey-username"
              type="text"
              name="username"
              autocomplete="username webauthn"
              required
            />
          </label>
          <label class="field" id="passkey-display-name-field">
            <span>表示名</span>
            <input
              id="passkey-display-name"
              type="text"
              name="displayName"
              autocomplete="name"
            />
          </label>
          <label class="field" for="passkey-nickname">
            <span>パスキーのニックネーム</span>
            <input
              id="passkey-nickname"
              type="text"
              name="nickname"
              placeholder="仕事用ノートPC"
              required
            />
          </label>
          <div class="button-row align-end">
            <button type="button" id="cancel-passkey-dialog" class="secondary">
              キャンセル
            </button>
            <button type="submit" id="submit-passkey-dialog" class="primary">
              続行
            </button>
          </div>
        </form>
      </dialog>
    </main>

    <script type="module">
      import {
        browserSupportsWebAuthn,
        createClient,
      } from "/webauthn/client.js";

      const client = createClient();

      const storageKey = "passkeys.currentUsername";

      const toastEl = document.getElementById("toast");
      const guestView = document.getElementById("guest-view");
      const accountView = document.getElementById("account-view");
      const guestHint = document.getElementById("guest-hint");
      const retrySigninButton = document.getElementById("retry-signin");
      const conditionalStatus = document.getElementById(
        "conditional-status",
      );
      const createAccountButton = document.getElementById(
        "open-create-account",
      );
      const accountSummary = document.getElementById("account-summary");
      const logoutButton = document.getElementById("logout");
      const deleteAccountButton = document.getElementById(
        "delete-account",
      );
      const profileForm = document.getElementById("profile-form");
      const accountUsernameInput = document.getElementById(
        "account-username",
      );
      const accountDisplayNameInput = document.getElementById(
        "account-display-name",
      );
      const profileSubmitButton = profileForm.querySelector(
        'button[type="submit"]',
      );
      const addPasskeyButton = document.getElementById("add-passkey");
      const credentialsList = document.getElementById(
        "credential-list",
      );
      const passkeyDialog = document.getElementById("passkey-dialog");
      const passkeyForm = document.getElementById("passkey-form");
      const passkeyDialogTitle = document.getElementById(
        "passkey-dialog-title",
      );
      const passkeyDialogDescription = document.getElementById(
        "passkey-dialog-description",
      );
      const passkeyUsernameField = document.getElementById(
        "passkey-username-field",
      );
      const passkeyUsernameInput = document.getElementById(
        "passkey-username",
      );
      const passkeyDisplayNameField = document.getElementById(
        "passkey-display-name-field",
      );
      const passkeyDisplayNameInput = document.getElementById(
        "passkey-display-name",
      );
      const passkeyNicknameInput = document.getElementById(
        "passkey-nickname",
      );
      const passkeyDialogCancel = document.getElementById(
        "cancel-passkey-dialog",
      );
      const passkeyDialogSubmit = document.getElementById(
        "submit-passkey-dialog",
      );
      const fallbackView = document.getElementById("fallback-view");
      const remoteQrContainer = document.getElementById("remote-qr");
      const remoteStatusText = document.getElementById("remote-status");
      const remoteRefreshButton = document.getElementById(
        "remote-refresh",
      );
      const remoteNotice = document.getElementById("remote-notice");

      const state = {
        account: null,
        credentials: [],
        conditionalAvailable: null,
        knownUsername: "",
      };

      const remoteState = {
        token: (() => {
          try {
            const url = new URL(window.location.href);
            const value = url.searchParams.get("remote");
            return value ? value.trim() || null : null;
          } catch {
            return null;
          }
        })(),
        sessionId: null,
        pollToken: null,
        claimToken: null,
        eventSource: null,
        authorized: false,
      };

      const isMobileDevice =
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i
          .test(navigator.userAgent);

      let toastTimeout = null;

      const hideToast = () => {
        if (!toastEl) {
          return;
        }
        if (toastTimeout) {
          clearTimeout(toastTimeout);
          toastTimeout = null;
        }
        toastEl.hidden = true;
      };

      const setStatus = (message, type = "info", options = {}) => {
        if (!toastEl) {
          return;
        }
        if (toastTimeout) {
          clearTimeout(toastTimeout);
          toastTimeout = null;
        }
        toastEl.textContent = message;
        toastEl.dataset.status = type;
        toastEl.hidden = false;
        const duration = typeof options.duration === "number"
          ? options.duration
          : null;
        if (duration && duration > 0) {
          toastTimeout = window.setTimeout(() => {
            hideToast();
          }, duration);
        }
      };

      let supportsPasskeys = false;

      const setGuestHint = (message) => {
        if (guestHint) {
          guestHint.textContent = message;
        }
      };

      const updateRetryButtonVisibility = () => {
        if (!retrySigninButton) {
          return;
        }
        retrySigninButton.hidden = !state.knownUsername;
      };

      const updateSignUpButtonVisibility = () => {
        if (!createAccountButton) {
          return;
        }
        createAccountButton.hidden = !supportsPasskeys;
      };

      const formatDate = (value) => {
        try {
          const date = new Date(value);
          if (Number.isNaN(date.getTime())) {
            return "-";
          }
          return date.toLocaleString();
        } catch {
          return "-";
        }
      };

      const storeUsername = (value) => {
        const normalized = typeof value === "string"
          ? value.trim()
          : "";
        state.knownUsername = normalized;
        try {
          if (normalized) {
            localStorage.setItem(storageKey, normalized);
          } else {
            localStorage.removeItem(storageKey);
          }
        } catch {
          // ignore storage failures
        }
        updateRetryButtonVisibility();
      };

      const getStoredUsername = () => {
        try {
          const value = localStorage.getItem(storageKey) ?? "";
          return value.trim();
        } catch {
          return "";
        }
      };

      const updateViews = () => {
        const hasAccount = Boolean(state.account);
        guestView.hidden = hasAccount;
        accountView.hidden = !hasAccount;
      };

      const renderCredentials = (credentials) => {
        credentialsList.innerHTML = "";
        if (!state.account) {
          const li = document.createElement("li");
          li.className = "empty";
          li.textContent = "サインインするとパスキーが表示されます。";
          credentialsList.append(li);
          return;
        }
        if (!credentials.length) {
          const li = document.createElement("li");
          li.className = "empty";
          li.textContent = "まだパスキーが登録されていません。";
          credentialsList.append(li);
          return;
        }
        for (const credential of credentials) {
          const li = document.createElement("li");

          const header = document.createElement("div");
          header.className = "credential-header";
          const title = document.createElement("strong");
          title.textContent = credential.nickname ||
            "名前のないデバイス";
          header.append(title);

          const deleteButton = document.createElement("button");
          deleteButton.type = "button";
          deleteButton.className = "danger outline";
          deleteButton.dataset.credentialId = credential.id;
          deleteButton.textContent = "削除";
          header.append(deleteButton);
          li.append(header);

          const meta = document.createElement("div");
          meta.className = "credential-meta";

          const rows = [
            ["デバイス", credential.deviceType ?? "不明"],
            ["バックアップ", credential.backedUp ? "はい" : "いいえ"],
            ["追加日", formatDate(credential.createdAt)],
            ["更新日", formatDate(credential.updatedAt)],
            [
              "ID",
              credential.id.length > 14
                ? `${credential.id.slice(0, 6)}…${
                  credential.id.slice(-6)
                }`
                : credential.id,
            ],
          ];

          for (const [label, value] of rows) {
            const row = document.createElement("div");
            const labelEl = document.createElement("span");
            labelEl.textContent = `${label}`;
            const valueEl = document.createElement("span");
            valueEl.textContent = `${value}`;
            valueEl.style.fontWeight = "500";
            row.append(labelEl, valueEl);
            meta.append(row);
          }

          li.append(meta);
          credentialsList.append(li);
        }
      };

      const renderAccount = () => {
        const account = state.account;
        if (!account) {
          accountSummary.textContent =
            "サインインしてアカウントを管理しましょう。";
          accountUsernameInput.value = "";
          accountDisplayNameInput.value = "";
          renderCredentials([]);
          updateViews();
          setGuestHint(
            "パスキーが登録されていれば自動的にサインインします。",
          );
          return;
        }
        const { user, credentials } = account;
        accountSummary.textContent = user.displayName
          ? `${user.displayName} · ${user.username}`
          : user.username;
        accountUsernameInput.value = user.username;
        accountDisplayNameInput.value = user.displayName ?? "";
        renderCredentials(credentials);
        updateViews();
        if (fallbackView) {
          fallbackView.hidden = true;
        }
        closeRemoteEventSource();
      };

      const setAccount = (account) => {
        if (account && account.user) {
          state.account = {
            user: account.user,
            credentials: Array.isArray(account.credentials)
              ? account.credentials
              : [],
          };
          state.credentials = state.account.credentials;
        } else {
          state.account = null;
          state.credentials = [];
        }
        renderAccount();
      };

      const getSession = async () => {
        try {
          const response = await fetch("/session", {
            credentials: "include",
          });
          if (!response.ok) {
            return null;
          }
          return await response.json();
        } catch {
          return null;
        }
      };

      const extractErrorMessage = async (response) => {
        try {
          const json = await response.clone().json();
          if (json && typeof json === "object" && "message" in json) {
            const message = json.message;
            if (typeof message === "string" && message.trim()) {
              return message.trim();
            }
          }
        } catch {
          // ignore
        }
        try {
          const text = await response.text();
          if (text.trim()) {
            return text.trim();
          }
        } catch {
          // ignore
        }
        return `リクエストがステータス${response.status}で失敗しました`;
      };

      let qrModulePromise = null;

      const ensureQrModule = async () => {
        if (!qrModulePromise) {
          qrModulePromise = import(
            "https://taisukef.github.io/qrcode-generator/es/QR.js"
          );
        }
        return qrModulePromise;
      };

      const closeRemoteEventSource = () => {
        if (remoteState.eventSource) {
          remoteState.eventSource.close();
          remoteState.eventSource = null;
        }
      };

      const renderRemoteQr = async (value) => {
        if (!remoteQrContainer) {
          return;
        }
        remoteQrContainer.replaceChildren();
        if (!value) {
          remoteQrContainer.textContent = "-";
          return;
        }
        try {
          const { QR } = await ensureQrModule();
          const matrix = QR.encode(value);
          if (!Array.isArray(matrix) || matrix.length === 0) {
            throw new Error("QR matrix was empty");
          }
          const margin = 1;
          const gridSize = matrix.length + margin * 2;
          let pathData = "";
          for (let y = 0; y < matrix.length; y++) {
            const row = matrix[y];
            for (let x = 0; x < row.length; x++) {
              if (row[x]) {
                const px = x + margin;
                const py = y + margin;
                pathData += `M${px} ${py}h1v1h-1z`;
              }
            }
          }
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg",
          );
          svg.setAttribute("viewBox", `0 0 ${gridSize} ${gridSize}`);
          svg.setAttribute("width", "240");
          svg.setAttribute("height", "240");
          svg.setAttribute("role", "img");
          svg.setAttribute("aria-label", "ログイン用QRコード");
          const background = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "rect",
          );
          background.setAttribute("width", String(gridSize));
          background.setAttribute("height", String(gridSize));
          background.setAttribute("fill", "#fff");
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          path.setAttribute("fill", "#000");
          path.setAttribute("d", pathData);
          svg.append(background, path);
          remoteQrContainer.append(svg);
        } catch (error) {
          console.error("Failed to render QR code:", error);
          const code = document.createElement("code");
          code.textContent = value;
          remoteQrContainer.append(code);
        }
      };

      const authorizeRemoteSession = async () => {
        if (!remoteState.token || remoteState.authorized) {
          return;
        }
        try {
          const response = await fetch("/remote-auth/authorize", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: remoteState.token }),
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          remoteState.authorized = true;
          if (remoteNotice) {
            remoteNotice.hidden = false;
            remoteNotice.dataset.state = "success";
            remoteNotice.textContent =
              "別のデバイスにサインイン情報を送信しました。";
          }
        } catch (error) {
          console.error("Failed to authorise remote session:", error);
          if (remoteNotice) {
            remoteNotice.hidden = false;
            remoteNotice.dataset.state = "error";
            remoteNotice.textContent = error?.message
              ? `デスクトップへの共有に失敗しました: ${error.message}`
              : "デスクトップへの共有に失敗しました。";
          }
        }
      };

      const fetchAccount = async (username) => {
        const normalized = username.trim();
        if (!normalized) {
          throw new Error("ユーザー名は必須です。");
        }
        const response = await fetch(
          `/webauthn/credentials?username=${
            encodeURIComponent(normalized)
          }`,
          { credentials: "include" },
        );
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error("アカウントが見つかりません。");
          }
          throw new Error(await extractErrorMessage(response));
        }
        const data = await response.json();
        if (!data || typeof data !== "object" || !data.user) {
          throw new Error("アカウントが見つかりません。");
        }
        const credentials = Array.isArray(data.credentials)
          ? data.credentials
          : [];
        return { user: data.user, credentials };
      };

      const loadAccount = async (username) => {
        const account = await fetchAccount(username);
        setAccount(account);
        storeUsername(account.user.username);
        if (remoteState.token && !remoteState.authorized) {
          await authorizeRemoteSession();
        }
        return account;
      };

      const finalizeRemoteClaim = async () => {
        if (
          !remoteState.sessionId ||
          !remoteState.pollToken ||
          !remoteState.claimToken ||
          !remoteStatusText
        ) {
          return;
        }
        try {
          remoteStatusText.dataset.state = "authorizing";
          remoteStatusText.textContent =
            "別のデバイスからの認証を確認しています…";
          const response = await fetch("/remote-auth/claim", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              sessionId: remoteState.sessionId,
              pollToken: remoteState.pollToken,
              claimToken: remoteState.claimToken,
            }),
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          const data = await response.json();
          if (!data || typeof data !== "object" || !data.user) {
            throw new Error("サーバーから予期しない応答がありました。");
          }
          remoteStatusText.dataset.state = "success";
          remoteStatusText.textContent = "サインインに成功しました。";
          closeRemoteEventSource();
          await loadAccount(data.user.username);
          setStatus("サインインに成功しました。", "success");
          if (fallbackView) {
            fallbackView.hidden = true;
          }
        } catch (error) {
          console.error("Failed to finalise remote session:", error);
          remoteState.claimToken = null;
          remoteStatusText.dataset.state = "error";
          remoteStatusText.textContent = error?.message
            ? `サインインの完了に失敗しました: ${error.message}`
            : "サインインの完了に失敗しました。";
          if (remoteRefreshButton) {
            remoteRefreshButton.disabled = false;
          }
        }
      };

      const handleRemoteUpdate = async (event) => {
        if (!remoteStatusText) {
          return;
        }
        let payload;
        try {
          payload = JSON.parse(event.data);
        } catch {
          return;
        }
        const status = payload?.status ?? "pending";
        switch (status) {
          case "pending":
            remoteState.claimToken = null;
            remoteStatusText.dataset.state = "waiting";
            remoteStatusText.textContent =
              "スマートフォンでQRコードを読み取り、サインインしてください。";
            break;
          case "authorized":
            remoteState.claimToken =
              typeof payload.claimToken === "string"
                ? payload.claimToken
                : null;
            remoteStatusText.dataset.state = "authorized";
            if (payload.user && typeof payload.user === "object") {
              const display = payload.user.displayName ||
                payload.user.username;
              remoteStatusText.textContent = display
                ? `${display} さんの認証情報を受信しました。確認しています…`
                : "認証情報を確認しています…";
            } else {
              remoteStatusText.textContent =
                "認証情報を受信しました。確認しています…";
            }
            if (remoteState.claimToken) {
              await finalizeRemoteClaim();
            }
            break;
          case "claimed":
            remoteStatusText.dataset.state = "success";
            remoteStatusText.textContent =
              "サインイン処理を完了しました。";
            closeRemoteEventSource();
            break;
          case "expired":
            remoteState.claimToken = null;
            remoteStatusText.dataset.state = "error";
            remoteStatusText.textContent =
              "QRコードの有効期限が切れました。再生成してください。";
            closeRemoteEventSource();
            if (remoteRefreshButton) {
              remoteRefreshButton.disabled = false;
            }
            break;
          default:
            remoteStatusText.dataset.state = "info";
            remoteStatusText.textContent = "状態を確認しています…";
        }
      };

      const startRemoteSession = async () => {
        if (!remoteStatusText) {
          return;
        }
        remoteState.sessionId = null;
        remoteState.pollToken = null;
        remoteState.claimToken = null;
        remoteStatusText.dataset.state = "pending";
        remoteStatusText.textContent = "QRコードを生成しています…";
        if (remoteRefreshButton) {
          remoteRefreshButton.disabled = true;
        }
        closeRemoteEventSource();
        try {
          const response = await fetch("/remote-auth/session", {
            method: "POST",
            credentials: "include",
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          const data = await response.json();
          if (
            !data ||
            typeof data !== "object" ||
            typeof data.sessionId !== "string" ||
            typeof data.pollToken !== "string" ||
            typeof data.loginUrl !== "string"
          ) {
            throw new Error("サーバーから予期しない応答がありました。");
          }
          remoteState.sessionId = data.sessionId;
          remoteState.pollToken = data.pollToken;
          await renderRemoteQr(data.loginUrl);
          remoteStatusText.dataset.state = "waiting";
          remoteStatusText.textContent =
            "スマートフォンでQRコードを読み取り、サインインしてください。";
          const eventsUrl = `/remote-auth/events?session=${
            encodeURIComponent(
              data.sessionId,
            )
          }&token=${encodeURIComponent(data.pollToken)}`;
          const source = new EventSource(eventsUrl, {
            withCredentials: true,
          });
          source.addEventListener("update", handleRemoteUpdate);
          source.onerror = () => {
            remoteStatusText.dataset.state = "error";
            remoteStatusText.textContent =
              "接続が中断されました。QRコードを再生成してください。";
            closeRemoteEventSource();
            if (remoteRefreshButton) {
              remoteRefreshButton.disabled = false;
            }
          };
          remoteState.eventSource = source;
        } catch (error) {
          console.error("Failed to create remote session:", error);
          remoteStatusText.dataset.state = "error";
          remoteStatusText.textContent = error?.message
            ? `QRコードを生成できませんでした: ${error.message}`
            : "QRコードを生成できませんでした。";
        } finally {
          if (remoteRefreshButton) {
            remoteRefreshButton.disabled = false;
          }
        }
      };

      const showRemoteFallback = async () => {
        if (!fallbackView || remoteState.token) {
          return;
        }
        if (fallbackView.hidden) {
          fallbackView.hidden = false;
        }
        if (!remoteState.sessionId) {
          await startRemoteSession();
        }
      };

      const hideRemoteFallback = () => {
        if (fallbackView && !fallbackView.hidden) {
          fallbackView.hidden = true;
        }
        if (!remoteState.token) {
          closeRemoteEventSource();
        }
      };

      const prepareRemoteJoin = async () => {
        if (!remoteState.token || !remoteNotice) {
          return;
        }
        remoteNotice.hidden = false;
        remoteNotice.dataset.state = "pending";
        remoteNotice.textContent = "接続状況を確認しています…";
        try {
          const response = await fetch(
            `/remote-auth/session?token=${
              encodeURIComponent(remoteState.token)
            }`,
            { credentials: "include" },
          );
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          const data = await response.json();
          if (data?.status === "expired") {
            remoteNotice.dataset.state = "error";
            remoteNotice.textContent =
              "このリンクの有効期限が切れています。もう一度QRコードを表示してください。";
          } else {
            remoteNotice.dataset.state = "info";
            remoteNotice.textContent =
              "デスクトップがサインインを待機しています。パスキーでサインインしてください。";
          }
        } catch (error) {
          remoteNotice.dataset.state = "error";
          remoteNotice.textContent = error?.message
            ? `接続を確認できませんでした: ${error.message}`
            : "接続を確認できませんでした。";
        }
      };

      const handleMissingPasskey = async () => {
        if (!state.knownUsername) {
          setGuestHint(
            "まだパスキーが登録されていません。スマートフォンでサインインするか、パスキーでサインアップしてください。",
          );
        } else {
          setGuestHint(
            "このアカウントのパスキーが見つかりません。スマートフォンでサインインするか、新しく登録してください。",
          );
        }
        updateSignUpButtonVisibility();
        if (
          !remoteState.token && (!supportsPasskeys || !isMobileDevice)
        ) {
          await showRemoteFallback();
        } else if (!remoteState.token) {
          hideRemoteFallback();
        }
      };

      if (remoteRefreshButton) {
        remoteRefreshButton.addEventListener("click", () => {
          startRemoteSession().catch((error) => {
            console.error("Failed to restart remote session:", error);
          });
        });
      }

      const refreshAccount = async () => {
        if (!state.account) {
          return;
        }
        const username = state.account.user.username;
        try {
          await loadAccount(username);
        } catch (error) {
          setStatus(
            error.message ?? "アカウントを更新できません。",
            "error",
          );
        }
      };

      const clearAccount = () => {
        setAccount(null);
      };

      const parseAuthenticationError = (error) => {
        if (error instanceof DOMException) {
          switch (error.name) {
            case "NotAllowedError":
            case "AbortError":
              return {
                message: "パスキーの操作がキャンセルされました。",
                type: "info",
                reason: "cancelled",
              };
            case "InvalidStateError":
              return {
                message:
                  "このデバイスには既にこのアカウントのパスキーがあります。別の認証器を使用するか既存の鍵を削除してください。",
                type: "error",
                reason: "invalid-state",
              };
            default:
              if (error.message?.trim()) {
                return {
                  message: `サインインに失敗しました: ${error.message}`,
                  type: "error",
                  reason: "unknown",
                };
              }
              return {
                message: "サインインに失敗しました。",
                type: "error",
                reason: "unknown",
              };
          }
        }
        const status = typeof error?.status === "number"
          ? error.status
          : null;
        const message = typeof error?.message === "string"
          ? error.message.trim()
          : "";
        if (status === 404 || status === 400) {
          return {
            message: message ||
              "パスキーが見つかりませんでした。新しく登録してください。",
            type: "info",
            reason: "no-account",
          };
        }
        if (message) {
          return {
            message: `サインインに失敗しました: ${message}`,
            type: "error",
            reason: "unknown",
          };
        }
        return {
          message: "サインインがキャンセルされたか失敗しました。",
          type: "error",
          reason: "unknown",
        };
      };

      const authenticateWithPasskey = async (
        username,
        options = {},
      ) => {
        const normalized = typeof username === "string"
          ? username.trim()
          : "";
        const silent = Boolean(options.silent);
        if (!normalized) {
          if (!silent) {
            setStatus(
              "サインインするにはユーザー名が必要です。",
              "error",
            );
          }
          return { success: false, reason: "missing-username" };
        }
        if (!silent) {
          setStatus("パスキーの操作を待機しています…");
        }
        try {
          await client.authenticate({ username: normalized });
          await loadAccount(normalized);
          setStatus("サインインに成功しました。", "success");
          return { success: true };
        } catch (error) {
          const failure = parseAuthenticationError(error);
          if (!silent) {
            setStatus(failure.message, failure.type);
          }
          return {
            success: false,
            reason: failure.reason,
            error,
            message: failure.message,
            type: failure.type,
          };
        }
      };

      const checkConditionalMediation = async () => {
        if (
          typeof PublicKeyCredential === "undefined" ||
          typeof PublicKeyCredential.isConditionalMediationAvailable !==
            "function"
        ) {
          conditionalStatus.textContent =
            "ご利用のブラウザーはまだパスキーの自動入力に対応していません。";
          conditionalStatus.dataset.state = "unsupported";
          return false;
        }
        try {
          const available = await PublicKeyCredential
            .isConditionalMediationAvailable();
          state.conditionalAvailable = available;
          conditionalStatus.textContent = available
            ? "このブラウザーではパスキーの自動入力が利用できます。"
            : "パスキーの自動入力は無効です。手動でサインインできます。";
          conditionalStatus.dataset.state = available
            ? "available"
            : "absent";
          return available;
        } catch (error) {
          console.error(
            "Failed to detect conditional mediation:",
            error,
          );
          conditionalStatus.textContent =
            "パスキーの自動入力に対応しているか判定できませんでした。";
          conditionalStatus.dataset.state = "error";
          return false;
        }
      };

      if (retrySigninButton) {
        retrySigninButton.addEventListener("click", async () => {
          if (retrySigninButton.dataset.loading === "true") {
            return;
          }
          const username = state.knownUsername;
          if (!username) {
            setStatus(
              "サインインするにはユーザー名を指定してください。",
              "error",
            );
            return;
          }
          retrySigninButton.dataset.loading = "true";
          retrySigninButton.disabled = true;
          try {
            const result = await authenticateWithPasskey(username);
            if (!result.success && result.reason === "no-account") {
              await handleMissingPasskey();
            }
          } finally {
            retrySigninButton.dataset.loading = "false";
            retrySigninButton.disabled = false;
          }
        });
      }

      const openPasskeyDialog = (mode) => {
        passkeyDialog.dataset.mode = mode;
        const defaultUsername = state.account?.user?.username ||
          state.knownUsername;
        if (mode === "create") {
          passkeyDialogTitle.textContent = "アカウントを作成";
          passkeyDialogDescription.textContent =
            "このユーザー名に最初のパスキーを登録します。";
          if (passkeyUsernameField) {
            passkeyUsernameField.hidden = false;
          }
          if (passkeyUsernameInput) {
            passkeyUsernameInput.value = defaultUsername || "";
          }
          passkeyDisplayNameField.hidden = false;
          passkeyDialogSubmit.textContent = "アカウントを作成";
          passkeyDisplayNameInput.value = defaultUsername || "";
        } else {
          passkeyDialogTitle.textContent = "別のパスキーを追加";
          passkeyDialogDescription.textContent =
            "後から分かるように鍵に名前を付けてください。";
          if (passkeyUsernameField) {
            passkeyUsernameField.hidden = true;
          }
          if (passkeyUsernameInput) {
            passkeyUsernameInput.value =
              state.account?.user?.username || "";
          }
          passkeyDisplayNameField.hidden = true;
          passkeyDialogSubmit.textContent = "パスキーを保存";
          if (state.account?.user?.displayName) {
            passkeyDisplayNameInput.value =
              state.account.user.displayName;
          } else {
            passkeyDisplayNameInput.value = "";
          }
        }
        passkeyNicknameInput.value = "";
        try {
          passkeyDialog.showModal();
          if (mode === "create" && passkeyUsernameInput) {
            passkeyUsernameInput.focus();
          } else {
            passkeyNicknameInput.focus();
          }
        } catch (error) {
          console.error("Unable to open dialog:", error);
        }
      };

      if (createAccountButton) {
        createAccountButton.addEventListener("click", () => {
          openPasskeyDialog("create");
        });
      }

      addPasskeyButton.addEventListener("click", () => {
        if (!state.account) {
          setStatus(
            "新しいパスキーを追加する前にサインインしてください。",
            "error",
          );
          return;
        }
        openPasskeyDialog("add");
      });

      passkeyDialogCancel.addEventListener("click", () => {
        passkeyDialog.close();
      });

      passkeyDialog.addEventListener("close", () => {
        passkeyForm.dataset.loading = "false";
      });

      passkeyForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (passkeyForm.dataset.loading === "true") {
          return;
        }
        const nickname = passkeyNicknameInput.value.trim();
        if (!nickname) {
          setStatus(
            "パスキーのニックネームを入力してください。",
            "error",
          );
          passkeyNicknameInput.focus();
          return;
        }
        const mode = passkeyDialog.dataset.mode ?? "add";
        passkeyForm.dataset.loading = "true";
        passkeyDialogSubmit.disabled = true;
        try {
          if (mode === "create") {
            const username = passkeyUsernameInput
              ? passkeyUsernameInput.value.trim()
              : "";
            if (!username) {
              throw new Error("ユーザー名は必須です。");
            }
            const displayName = passkeyDisplayNameInput.value.trim();
            setStatus("セキュリティキーの操作を待機しています…");
            await client.register({
              username,
              displayName: displayName || undefined,
              nickname,
            });
            setStatus(
              `パスキー「${nickname}」を登録しました。`,
              "success",
            );
            passkeyDialog.close();
            storeUsername(username);
            updateRetryButtonVisibility();
            await authenticateWithPasskey(username);
          } else {
            if (!state.account) {
              throw new Error("サインイン中のアカウントがありません。");
            }
            const username = state.account.user.username;
            setStatus("セキュリティキーの操作を待機しています…");
            await client.register({
              username,
              displayName: state.account.user.displayName || undefined,
              nickname,
            });
            setStatus(
              `パスキー「${nickname}」を追加しました。`,
              "success",
            );
            passkeyDialog.close();
            await refreshAccount();
          }
        } catch (error) {
          let message = "パスキーの設定に失敗しました。";
          let statusType = "error";
          if (error instanceof DOMException) {
            switch (error.name) {
              case "NotAllowedError":
                message =
                  "このデバイスには既にこのアカウントのパスキーがあります。別の認証器を使用するか既存の鍵を削除してください。";
                break;
              case "InvalidStateError":
                message =
                  "この認証器は既にこのアカウントに登録されているため要求を拒否しました。";
                break;
              case "AbortError":
                message = "パスキーの設定がキャンセルされました。";
                statusType = "info";
                break;
              default:
                if (error.message?.trim()) {
                  message =
                    `パスキーの設定に失敗しました: ${error.message}`;
                }
                break;
            }
          } else if (error instanceof Error && error.message.trim()) {
            message = `パスキーの設定に失敗しました: ${error.message}`;
          }
          setStatus(message, statusType);
        } finally {
          passkeyDialogSubmit.disabled = false;
          passkeyForm.dataset.loading = "false";
        }
      });

      credentialsList.addEventListener("click", async (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const button = target.closest("button[data-credential-id]");
        if (!(button instanceof HTMLButtonElement)) {
          return;
        }
        if (!state.account) {
          setStatus(
            "パスキーを管理する前にサインインしてください。",
            "error",
          );
          return;
        }
        const credentialId = button.dataset.credentialId;
        if (!credentialId) {
          return;
        }
        if (button.dataset.loading === "true") {
          return;
        }
        button.dataset.loading = "true";
        button.disabled = true;
        try {
          setStatus("パスキーを削除しています…");
          await client.delete({
            username: state.account.user.username,
            credentialId,
          });
          setStatus("パスキーを削除しました。", "success");
          await refreshAccount();
        } catch (error) {
          setStatus(
            error?.message
              ? `パスキーの削除に失敗しました: ${error.message}`
              : "パスキーの削除に失敗しました。",
            "error",
          );
        } finally {
          button.dataset.loading = "false";
          button.disabled = false;
        }
      });

      profileForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (!state.account) {
          setStatus(
            "プロフィールを更新する前にサインインしてください。",
            "error",
          );
          return;
        }
        if (profileForm.dataset.loading === "true") {
          return;
        }
        const username = accountUsernameInput.value.trim();
        const displayName = accountDisplayNameInput.value.trim();
        const payload = {};
        if (username && username !== state.account.user.username) {
          payload.username = username;
        }
        if (displayName !== state.account.user.displayName) {
          payload.displayName = displayName;
        }
        if (Object.keys(payload).length === 0) {
          setStatus("保存する変更がありません。", "info");
          return;
        }
        profileForm.dataset.loading = "true";
        profileSubmitButton.disabled = true;
        try {
          const response = await fetch("/account", {
            method: "PATCH",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          const data = await response.json();
          if (!data || typeof data !== "object" || !data.user) {
            throw new Error("サーバーから予期しない応答がありました。");
          }
          state.account = {
            user: data.user,
            credentials: state.credentials,
          };
          storeUsername(data.user.username);
          renderAccount();
          setStatus("プロフィールを更新しました。", "success");
        } catch (error) {
          setStatus(
            error?.message
              ? `プロフィールの保存に失敗しました: ${error.message}`
              : "プロフィールの保存に失敗しました。",
            "error",
          );
        } finally {
          profileForm.dataset.loading = "false";
          profileSubmitButton.disabled = false;
        }
      });

      logoutButton.addEventListener("click", async () => {
        if (logoutButton.dataset.loading === "true") {
          return;
        }
        logoutButton.dataset.loading = "true";
        logoutButton.disabled = true;
        try {
          const response = await fetch("/session/logout", {
            method: "POST",
            credentials: "include",
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          clearAccount();
          setStatus("サインアウトしました。", "info");
        } catch (error) {
          setStatus(
            error?.message
              ? `サインアウトに失敗しました: ${error.message}`
              : "サインアウトに失敗しました。",
            "error",
          );
        } finally {
          logoutButton.dataset.loading = "false";
          logoutButton.disabled = false;
        }
      });

      deleteAccountButton.addEventListener("click", async () => {
        if (!state.account) {
          setStatus(
            "アカウントを削除する前にサインインしてください。",
            "error",
          );
          return;
        }
        if (deleteAccountButton.dataset.loading === "true") {
          return;
        }
        const confirmed = window.confirm(
          "アカウントを削除するとすべてのパスキーが消えます。この操作は取り消せません。続行しますか？",
        );
        if (!confirmed) {
          return;
        }
        deleteAccountButton.dataset.loading = "true";
        deleteAccountButton.disabled = true;
        try {
          const response = await fetch("/account", {
            method: "DELETE",
            credentials: "include",
          });
          if (!response.ok) {
            throw new Error(await extractErrorMessage(response));
          }
          clearAccount();
          setStatus("アカウントを削除しました。", "success");
        } catch (error) {
          setStatus(
            error?.message
              ? `アカウントの削除に失敗しました: ${error.message}`
              : "アカウントの削除に失敗しました。",
            "error",
          );
        } finally {
          deleteAccountButton.dataset.loading = "false";
          deleteAccountButton.disabled = false;
        }
      });

      const initialise = async () => {
        state.knownUsername = getStoredUsername();
        updateRetryButtonVisibility();

        supportsPasskeys = browserSupportsWebAuthn();
        updateSignUpButtonVisibility();

        if (remoteState.token) {
          await prepareRemoteJoin();
        }

        if (!supportsPasskeys && !remoteState.token) {
          clearAccount();
          setGuestHint(
            "このブラウザーはパスキーに対応していません。スマートフォンなどの対応デバイスでサインインしてください。",
          );
          if (!isMobileDevice) {
            await showRemoteFallback();
          } else {
            hideRemoteFallback();
          }
          setStatus(
            "このブラウザーではパスキーを利用できません。QRコードからサインインしてください。",
            "info",
          );
          return;
        }

        if (supportsPasskeys) {
          await checkConditionalMediation();
        } else {
          conditionalStatus.textContent =
            "このブラウザーではパスキーを利用できません。";
          conditionalStatus.dataset.state = "unsupported";
        }

        const session = await getSession();
        if (session?.isAuthenticated && session.user) {
          try {
            await loadAccount(session.user.username);
            setStatus("おかえりなさい。", "success");
            return;
          } catch (error) {
            console.error("Failed to restore session:", error);
            clearAccount();
            setStatus(
              "セッションを復元できませんでした。もう一度サインインしてください。",
              "error",
            );
            await handleMissingPasskey();
            return;
          }
        }

        clearAccount();

        if (state.knownUsername) {
          const result = await authenticateWithPasskey(
            state.knownUsername,
            {
              silent: true,
            },
          );
          if (result.success) {
            return;
          }
          if (result.reason === "no-account") {
            setStatus(
              "パスキーが見つかりませんでした。新しく登録してください。",
              "info",
            );
            await handleMissingPasskey();
            return;
          }
          if (result.message) {
            setStatus(result.message, result.type ?? "error");
          } else {
            setStatus(
              "パスキーの自動サインインを開始できませんでした。ボタンから再試行してください。",
              "info",
            );
          }
          setGuestHint(
            "保存されているパスキーでサインインするには「パスキーでサインイン」を押してください。",
          );
          hideRemoteFallback();
          return;
        }

        await handleMissingPasskey();

        if (!remoteState.token) {
          setStatus("準備が整いました。", "info");
        } else {
          setStatus(
            "デスクトップでサインインを完了してください。",
            "info",
          );
        }
      };

      await initialise();
    </script>
  </body>
</html>
